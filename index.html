<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Cinematic Memory Galaxy - Large & Clear</title>
    <style>
        /* --- 1. 沉浸式背景与全局样式 --- */
        body { 
            margin: 0; overflow: hidden; 
            background: radial-gradient(circle at center, #0a1a1a 0%, #000000 100%);
            font-family: 'Helvetica Neue', Arial, sans-serif; 
        }

        /* 电影胶片颗粒感叠加层 */
        body::after {
            content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.05'/%3E%3C/svg%3E");
            pointer-events: none; z-index: 5;
        }

        /* --- 2. 磨砂玻璃 UI 设计 --- */
        #video-container {
            position: absolute; top: 30px; right: 30px;
            width: 180px; height: 135px;
            border-radius: 16px; overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            z-index: 10; transition: all 0.5s cubic-bezier(0.25, 1, 0.5, 1);
        }
        
        #video-container.active { 
            border-color: rgba(0, 255, 157, 0.6); 
            box-shadow: 0 0 40px rgba(0, 255, 157, 0.2);
            transform: scale(1.05);
        }

        #input_video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.8; }

        #status {
            position: absolute; top: 180px; right: 30px;
            color: rgba(255, 255, 255, 0.8); 
            text-align: right; font-size: 12px; letter-spacing: 1px;
            pointer-events: none; line-height: 1.8; font-weight: 300;
            text-transform: uppercase;
        }
        b { color: #FFD700; font-weight: 600; }

        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #fff; z-index: 100;
            transition: opacity 1.5s ease-out; pointer-events: none;
        }
        .loading-bar { width: 200px; height: 2px; background: #333; margin-top: 20px; border-radius: 2px; overflow: hidden; }
        .progress { width: 100%; height: 100%; background: #FFD700; animation: load 2s infinite ease-in-out; transform-origin: left; }
        @keyframes load { 0% { transform: scaleX(0); } 50% { transform: scaleX(1); } 100% { transform: scaleX(0); transform-origin: right; } }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div style="font-size: 14px; letter-spacing: 3px; text-transform: uppercase;">Creating Universe</div>
        <div class="loading-bar"><div class="progress"></div></div>
    </div>
    
    <div id="video-container"><video id="input_video"></video></div>
    <div id="status">
        Using <b>Mediapipe AI</b> Engine<br>
        Open Palm: <b>Scatter View</b><br>
        Closed Fist: <b>Assemble Tree</b>
    </div>
    <div id="canvas-container"></div>

<script>
    // ==========================================
    // ⚙️ 用户配置区域 - 路径设置
    // ==========================================
    const FOLDER_PATH = './photo/'; 
    const INDEX_FILE = FOLDER_PATH + 'imagelist.json';
    // ==========================================

    // --- 1. 高级场景初始化 ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x02080a, 0.025); 

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    const initialCamPos = { x: 0, y: 8, z: 35 };
    camera.position.set(initialCamPos.x, initialCamPos.y, initialCamPos.z);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
    renderer.physicallyCorrectLights = true;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    // 保持曝光度为 1.0，我们会通过材质颜色来控制过曝
    renderer.toneMappingExposure = 1.0; 
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.05;
    controls.autoRotate = true; controls.autoRotateSpeed = 0.6;
    controls.enablePan = false;

    // --- 2. 电影级灯光系统 ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambientLight);

    const mainLight = new THREE.SpotLight(0xffeebb, 2000);
    mainLight.position.set(20, 30, 20);
    mainLight.angle = 0.6; mainLight.penumbra = 0.5; mainLight.castShadow = true;
    scene.add(mainLight);

    const rimLight = new THREE.SpotLight(0x44ddff, 1500);
    rimLight.position.set(-20, 10, -20);
    rimLight.lookAt(0,0,0);
    scene.add(rimLight);

    const bottomLight = new THREE.PointLight(0xc9ffe5, 500);
    bottomLight.position.set(0, -10, 0);
    scene.add(bottomLight);

    // --- 3. 拍立得纹理生成器 ---
    function createPolaroidTexture(img) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const size = 512; 
        const padding = 40;
        const bottomPadding = 100;

        canvas.width = size;
        canvas.height = size + bottomPadding - padding;

        ctx.fillStyle = '#f0f0f0'; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const aspect = img.width / img.height;
        let drawW, drawH, drawX, drawY;
        const targetW = size - padding * 2;
        const targetH = size - padding * 2;

        if(aspect > 1) { 
            drawH = targetH; drawW = targetH * aspect;
            drawY = padding; drawX = padding - (drawW - targetW)/2;
        } else { 
            drawW = targetW; drawH = targetW / aspect;
            drawX = padding; drawY = padding - (drawH - targetH)/2;
        }

        ctx.save();
        ctx.beginPath();
        ctx.rect(padding, padding, targetW, targetH);
        ctx.clip();
        ctx.drawImage(img, drawX, drawY, drawW, drawH);
        ctx.restore();

        const tex = new THREE.CanvasTexture(canvas);
        tex.encoding = THREE.sRGBEncoding;
        tex.minFilter = THREE.LinearFilter;
        return tex;
    }

    // --- 自动加载图片系统 ---
    const loader = new THREE.ImageLoader();
    const userTextures = [];
    
    const defaultUrls = [
        'https://images.unsplash.com/photo-1516724562728-afc824a36e84?ixlib=rb-1.2.1&auto=format&fit=crop&w=600&q=80',
        'https://images.unsplash.com/photo-1518176258769-f227c798150e?ixlib=rb-1.2.1&auto=format&fit=crop&w=600&q=80',
        'https://images.unsplash.com/photo-1496360166961-10a51d5f367a?ixlib=rb-1.2.1&auto=format&fit=crop&w=600&q=80'
    ];

    fetch(INDEX_FILE)
        .then(response => {
            if (!response.ok) throw new Error("JSON List not found");
            return response.json();
        })
        .then(fileNames => {
            fileNames.forEach(filename => {
                loader.load(FOLDER_PATH + filename, (image) => {
                    const tex = createPolaroidTexture(image);
                    userTextures.push(tex);
                });
            });
        })
        .catch(error => {
            console.warn("加载默认网络图片。", error);
            defaultUrls.forEach(url => {
                loader.load(url, (image) => {
                    userTextures.push(createPolaroidTexture(image));
                });
            });
        });

    function createColorTexture(color) {
        const c = document.createElement('canvas'); c.width=64; c.height=64;
        const x = c.getContext('2d'); x.fillStyle='#eee'; x.fillRect(0,0,64,64); x.fillStyle=color; x.fillRect(4,4,56,56);
        return new THREE.CanvasTexture(c);
    }
    const randColors = ['#E74C3C', '#3498DB', '#F1C40F'];

    // --- 4. 构建物体 ---
    const particles = [];
    const geometryCount = 450; 
    
    const matEmerald = new THREE.MeshStandardMaterial({ 
        color: 0x054a2e, roughness: 0.1, metalness: 0.6, envMapIntensity: 1.0 
    });
    const matGold = new THREE.MeshStandardMaterial({ 
        color: 0xffd700, roughness: 0.15, metalness: 1.0, emissive: 0x442200, emissiveIntensity: 0.2 
    });
    const matGift = new THREE.MeshStandardMaterial({ color: 0xcc2222, roughness: 0.3 });
    
    // 【修改点 1】将照片几何体尺寸放大 2 倍
    // 原来是 (1.6, 1.9)，现在改为 (3.2, 3.8)
    const geoPlane = new THREE.PlaneGeometry(3.2, 3.8);

    for (let i = 0; i < geometryCount; i++) {
        let mesh;
        let type = Math.random();

        if (type < 0.65) {
            // 【修改点 2】优化照片材质
            const mat = new THREE.MeshStandardMaterial({ 
                side: THREE.DoubleSide, 
                // 将颜色调暗至深灰色 (0x888888)，这相当于物理上的“减光镜”，
                // 即使强光照射，也不会反射出纯白的过曝效果。
                color: 0x888888,  
                roughness: 0.7, // 增加粗糙度，减少反光
                metalness: 0.0 
            });

            mat.map = createColorTexture(randColors[i%3]);
            mesh = new THREE.Mesh(geoPlane, mat);
            mesh.userData.isPhoto = true;
            mesh.userData.texIndex = i;
        } else if (type < 0.85) {
            mesh = new THREE.Mesh(new THREE.SphereGeometry(0.35, 32, 32), (Math.random()>0.5)?matEmerald:matGold);
        } else {
            mesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), matGift);
        }

        const t = i / geometryCount; 
        const angle = t * Math.PI * 25; 
        const radius = t * 9.5; 
        const treePos = { x: Math.cos(angle)*radius, y: 19 - t*19 - 9.5, z: Math.sin(angle)*radius };
        
        const u = Math.random(); const v = Math.random();
        const r = 18 + Math.random() * 25;
        const theta = 2 * Math.PI * u; 
        const phi = Math.acos(2 * v - 1);
        const scatterPos = { 
            x: r * Math.sin(phi) * Math.cos(theta), 
            y: (r * Math.sin(phi) * Math.sin(theta)) * 0.6, 
            z: r * Math.cos(phi) 
        };

        mesh.position.set(scatterPos.x, scatterPos.y, scatterPos.z);
        mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);

        mesh.userData.phase = Math.random() * Math.PI * 2;
        mesh.userData.speed = 0.5 + Math.random() * 0.5;
        mesh.userData.treePos = treePos;
        mesh.userData.treeRot = { x: -0.2, y: angle - Math.PI/2, z: 0 }; 
        mesh.userData.scatterPos = scatterPos;
        mesh.userData.scatterRot = { x: Math.random()*Math.PI, y: Math.random()*Math.PI, z: 0 }; 

        scene.add(mesh);
        particles.push(mesh);
    }

    // 树顶之星
    const starMesh = new THREE.Mesh(new THREE.OctahedronGeometry(1.2, 0), new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 3 }));
    starMesh.userData = { treePos: {x:0, y:10.5, z:0}, scatterPos: {x:0, y:30, z:0}, phase: 0, speed: 0 };
    scene.add(starMesh); particles.push(starMesh);

    // 魔法金沙
    const dustCount = 1500;
    const dustGeo = new THREE.BufferGeometry();
    const dustPos = [];
    for(let i=0; i<dustCount; i++) {
        dustPos.push((Math.random()-0.5)*60, (Math.random()-0.5)*50, (Math.random()-0.5)*60);
    }
    dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dustPos, 3));
    
    const dustMat = new THREE.PointsMaterial({
        color: 0xFFD700, size: 0.2, transparent: true, opacity: 0.6, 
        blending: THREE.AdditiveBlending, sizeAttenuation: true
    });
    const dustSys = new THREE.Points(dustGeo, dustMat);
    scene.add(dustSys);

    // --- 5. 电影级后处理 ---
    const composer = new THREE.EffectComposer(renderer);
    const renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);

    // 【修改点 3】调整辉光（Bloom）参数以修复过曝
    // threshold: 0.85 -> 只有亮度超过 0.85 的部分才会发光（照片现在是 0.88 的灰色基底，不会被误判发光）
    // strength: 0.6 -> 降低整体光晕强度，让细节更清晰
    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.85; 
    bloomPass.strength = 0.6; 
    bloomPass.radius = 0.5;
    composer.addPass(bloomPass);

    // --- 6. 交互逻辑 ---
    let currentState = 'scatter';
    let targetCameraOffset = {x:0, y:0};

    function transform(state) {
        if(currentState === state) return;
        currentState = state;
        controls.autoRotate = (state === 'tree');
        
        particles.forEach(p => {
            const t = (state==='tree')?p.userData.treePos:p.userData.scatterPos;
            const r = (state==='tree')?p.userData.treeRot:p.userData.scatterRot;
            
            const easing = (state==='tree') ? "back.out(1.2)" : "power2.out";
            const dur = 1.5 + Math.random();

            gsap.to(p.position, {x:t.x, y:t.y, z:t.z, duration:dur, ease: easing});
            if(r) gsap.to(p.rotation, {x:r.x, y:r.y, z:r.z, duration:dur, ease: "power2.out"});
        });
    }

    const videoElement = document.getElementById('input_video');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
    
    hands.onResults(results => {
        document.getElementById('loader').style.opacity = 0;
        
        if(results.multiHandLandmarks && results.multiHandLandmarks.length>0) {
            document.getElementById('video-container').classList.add('active');
            const lm = results.multiHandLandmarks[0];
            const wrist = lm[0];
            let dist = 0; [8,12,16,20].forEach(i=>dist+=Math.hypot(lm[i].x-wrist.x, lm[i].y-wrist.y)); dist/=4;
            
            if(dist < 0.25) transform('tree');
            else if(dist > 0.35) transform('scatter');

            if(currentState === 'scatter') {
                const MULTIPLIER = 70; 
                targetCameraOffset.x = (wrist.x - 0.5) * MULTIPLIER;
                targetCameraOffset.y = (0.5 - wrist.y) * MULTIPLIER;
            }
        } else {
            document.getElementById('video-container').classList.remove('active');
            targetCameraOffset = {x:0, y:0};
        }
    });

    const cameraUtils = new Camera(videoElement, { onFrame: async()=>{await hands.send({image:videoElement})}, width:320, height:240 });
    cameraUtils.start();

    // --- 7. 渲染循环 ---
    let time = 0;
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        time += dt;
        controls.update();

        if(userTextures.length > 0) {
            particles.forEach(p => {
                if(p.userData.isPhoto && !p.userData.texAssigned) {
                    p.material.map = userTextures[p.userData.texIndex % userTextures.length];
                    p.material.needsUpdate = true;
                    p.userData.texAssigned = true;
                }
            });
        }

        if(currentState === 'scatter') {
            particles.forEach(p => {
                p.position.y += Math.sin(time * p.userData.speed + p.userData.phase) * 0.008;
                p.rotation.z += Math.cos(time * 0.5 + p.userData.phase) * 0.002;
            });
        }

        const dPos = dustSys.geometry.attributes.position.array;
        for(let i=0; i<dustCount; i++){
            const ix = i*3; const iy = i*3+1; const iz = i*3+2;
            dPos[iy] += 0.03; 
            dPos[ix] += Math.sin(time * 0.5 + dPos[iy] * 0.1) * 0.02; 
            dPos[iz] += Math.cos(time * 0.3 + dPos[iy] * 0.1) * 0.02;

            if(dPos[iy] > 25) { 
                dPos[iy] = -25; 
                dPos[ix] = (Math.random()-0.5)*60; 
                dPos[iz] = (Math.random()-0.5)*60; 
            }
        }
        dustSys.geometry.attributes.position.needsUpdate = true;

        if(currentState === 'scatter'){
            const LERP = 0.12;
            camera.position.x += (initialCamPos.x + targetCameraOffset.x - camera.position.x) * LERP;
            camera.position.y += (initialCamPos.y + targetCameraOffset.y - camera.position.y) * LERP;
            camera.lookAt(0, 0, 0);
        } else {
            camera.position.y += (initialCamPos.y - camera.position.y) * 0.05;
        }

        composer.render();
    }
    animate();

    window.onresize=()=>{camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight);};
</script>
</body>
</html>